diff --git a/OpDebugDump.cpp b/OpDebugDump.cpp
index 13af218..8d9bf3c 100644
--- a/OpDebugDump.cpp
+++ b/OpDebugDump.cpp
@@ -892,6 +892,14 @@ void OpEdge::dump() const {
     OpDebugOut(s);
 }
 
+void dump(const OpEdge* edge) {
+    edge->dump();
+}
+
+void dump(const OpEdge& edge) {
+    edge.dump();
+}
+
 void OpEdge::dumpChain(EdgeLoop edgeLoop, bool detail) const {
     std::string s;
     if (EdgeLoop::link == edgeLoop)
@@ -1460,6 +1468,14 @@ void OpPoint::dump() const {
     OpDebugOut("OpPoint pt { " + debugDump() + " };\n");
 }
 
+void dump(const OpPoint& pt) {
+    pt.dump();
+}
+
+void dump(const OpPoint* pt) {
+    pt->dump();
+}
+
 void OpPoint::dumpHex() const {
     OpDebugOut("OpPoint pt { " + debugDumpHex() + " };  // " + debugDump() + "\n");
 }
@@ -1482,7 +1498,15 @@ void OpPtT::dump() const {
     OpDebugOut(debugDump() + "\n"); 
 }
 
-void OpPtT::dumpHex() const { 
+void dump(const OpPtT& ptT) {
+    ptT.dump();
+}
+
+void dump(const OpPtT* ptT) {
+    ptT->dump();
+}
+
+void OpPtT::dumpHex() const {
     OpDebugOut(debugDumpHex() + " // " + debugDump() + "\n");
 }
 
diff --git a/OpDebugDump.h b/OpDebugDump.h
index 26b5a36..33a6ef5 100644
--- a/OpDebugDump.h
+++ b/OpDebugDump.h
@@ -10,6 +10,7 @@ struct OpEdge;
 struct OpIntersection;
 struct OpOutPath;
 struct OpPoint;
+struct OpPtT;
 struct OpSegment;
 
 extern void dump(const std::vector<OpEdge>& );  // to dump edge list built from intersections
@@ -18,6 +19,13 @@ extern void dump(const std::vector<const OpEdge*>& ); // to dump debug image edg
 extern void dump(const std::vector<OpSegment*>& ); // to dump segment intersection pairs
 extern void dump(const OpOutPath& );
 
+extern void dump(const OpEdge*);
+extern void dump(const OpEdge&);
+extern void dump(const OpPtT*);
+extern void dump(const OpPtT&);
+extern void dump(const OpPoint*);
+extern void dump(const OpPoint&);
+
 #define DEBUG_COMMON_DECLARATIONS() \
     std::string debugDump() const; \
 	std::string debugDumpDetail() const; \
diff --git a/OpEdge.cpp b/OpEdge.cpp
index bc9e95c..6a0f357 100644
--- a/OpEdge.cpp
+++ b/OpEdge.cpp
@@ -226,17 +226,15 @@ bool OpEdge::containsLink(const OpEdge* edge) const {
 // for now, keep making it smaller until it breaks
 #define WINDING_NORMAL_LIMIT  0.001 // !!! no idea what this should be
 
-start here;
 // pass center as parameter so caller can specify their own middle
-OpPtT OpEdge::findRayIntercept(OpEdge* test, float lo, float hi, Axis axis, 
-		OpVector backRay) {
-	float normal = center.pt.choice(axis);
+OpPtT OpEdge::findRayIntercept(OpEdge* test, float normal, float loBound, float hiBound,
+		Axis axis, OpVector backRay) {
 	float mid = 1;
-	float midEnd = hi;
+	float midEnd = 1;
+	const OpCurve& testCurve = test->setCurve();
 	do {	// try to find ray; look up to eight times
-		const OpCurve& curve = test->setCurve();
 		OpRoots cepts;
-		cepts.count = curve.axisRayHit(axis, normal, cepts.roots);
+		cepts.count = testCurve.axisRayHit(axis, normal, cepts.roots);
 		// get the normal at the intersect point and see if it is usable
 		if (1 != cepts.count) {
 			// !!! if intercepts is 2 or 3, figure out why (and what to do)
@@ -246,25 +244,25 @@ OpPtT OpEdge::findRayIntercept(OpEdge* test, float lo, float hi, Axis axis,
 		}
 		float cept = cepts.get(0);
 		if (!OpMath::IsNaN(cept) && 0 != cept && 1 != cept) {
-			float tNxR = curve.tangent(cept).normalize().cross(backRay);
+			float tNxR = testCurve.tangent(cept).normalize().cross(backRay);
 			if (fabs(tNxR) >= WINDING_NORMAL_LIMIT
 					|| (test->setLinear() && test->start.t < cept && cept < test->end.t)) {
-				return OpPtT(curve.ptAtT(cept), cept); // no need to look for a better ray intersection
+				return OpPtT(testCurve.ptAtT(cept), cept); // no need to look for a better ray intersection
 			}
+			OpDebugOut("");
 		}
 		// recalc center; restart search for winding with a different ray
-		const OpCurve& edgeCurve = setCurve();
 		mid /= 2;
-		float newMid = (hi - lo) * mid;
-		midEnd = midEnd < (lo + hi) / 2 ? hi - newMid : lo + newMid;
-		float middle = OpMath::Interp(ptBounds.ltChoice(axis), ptBounds.rbChoice(axis), midEnd);
+		midEnd = midEnd < .5 ? 1 - mid : mid;
+		float middle = OpMath::Interp(loBound, hiBound, midEnd);
+		const OpCurve& edgeCurve = setCurve();  // ok to be in loop (lazy)
 		float t = edgeCurve.center(axis, middle);
-		normal = edgeCurve.ptAtT(t).choice(axis);
-		if (OpMath::IsNaN(t) || mid <= 1.f/256.f) {	// give it at most eight tries
+		if (OpMath::IsNaN(t) || mid <= 1.f / 256.f) {	// give it at most eight tries
 			fail = EdgeFail::recalcCenter;
 			winding.zero(ZeroReason::failCenter);
-			break;	
+			break;
 		}
+		normal = edgeCurve.ptAtT(t).choice(axis);
 		assert(!OpMath::IsNaN(normal));
 	} while (true);
 	return OpPtT();// no useful result
diff --git a/OpEdge.h b/OpEdge.h
index 9ad97e8..cbf36a6 100644
--- a/OpEdge.h
+++ b/OpEdge.h
@@ -316,7 +316,8 @@ public:
 	bool containsLink(const OpEdge* edge) const;
 	float findPtT(OpPoint pt) const;
 	OpPtT flipPtT(EdgeMatch match) const { return match == whichEnd ? end : start; }
-	OpPtT findRayIntercept(OpEdge* test, float lo, float hi, Axis, OpVector backRay);
+	OpPtT findRayIntercept(OpEdge* test, float normal, float lo, float hi, Axis , 
+			OpVector backRay);
 	void flipWhich() { whichEnd = (EdgeMatch)((int)whichEnd ^ (int)EdgeMatch::both); }
 	void findWinding(Axis axis  OP_DEBUG_PARAMS(int* debugWindingLimiter));
 	bool hasLinkTo(EdgeMatch match) const { 
diff --git a/OpEdges.cpp b/OpEdges.cpp
index 44bd682..904bea2 100644
--- a/OpEdges.cpp
+++ b/OpEdges.cpp
@@ -282,7 +282,8 @@ void OpEdges::setSumChain(std::vector <OpEdge*>& inArray, size_t inIndex, Axis a
 	OpVector backRay = -ray;
 	float center = edge->center.pt.choice(perpendicular);
 	float normal = edge->center.pt.choice(axis);
-	// mark all possible edges
+	float edgeCenterT = edge->center.t;
+	// advance to furthest that could influence the sum winding of this edge
 	inIndex += 1;
 	for (; inIndex < inArray.size(); ++inIndex) {
 		OpEdge* advance = inArray[inIndex];
@@ -290,25 +291,67 @@ void OpEdges::setSumChain(std::vector <OpEdge*>& inArray, size_t inIndex, Axis a
 			break;
 	}
 	std::vector<EdgeDistance> distance;
-	distance.emplace_back(edge, 0, edge->center.t);
-	// start at edge with left equal to or left of center
-	while (inIndex != 0) {
-		OpEdge* test = inArray[--inIndex];
-		if (test == edge)
-			continue;
-		if (!test->winding.visible())
-			continue;
-		if (test->ptBounds.ltChoice(axis) > normal)
-			continue;
-		if (test->ptBounds.rbChoice(axis) < normal)
-			continue;
-		OpPtT ptT = edge->findRayIntercept(test, 0, 1, axis, backRay);
-		if (!OpMath::IsNaN(ptT.t))
-			distance.emplace_back(test, center - ptT.pt.choice(perpendicular), ptT.t);
-	}
+	do {
+		float mid = 1;
+		float midEnd = 1;
+		distance.emplace_back(edge, 0, edgeCenterT);
+		int index = inIndex;
+		// start at edge with left equal to or left of center
+		while (index != 0) {
+			OpEdge* test = inArray[--index];
+			if (test == edge)
+				continue;
+			if (!test->winding.visible())
+				continue;
+			if (test->ptBounds.ltChoice(axis) > normal)
+				continue;
+			if (test->ptBounds.rbChoice(axis) < normal)
+				continue;
+			const OpCurve& testCurve = test->setCurve();
+			OpRoots cepts;
+			cepts.count = testCurve.axisRayHit(axis, normal, cepts.roots);
+			// get the normal at the intersect point and see if it is usable
+			if (1 != cepts.count) {
+				// !!! if intercepts is 2 or 3, figure out why (and what to do)
+				// !!! likely need to try a different ray
+				assert(0 == cepts.count);
+				continue;
+			}
+			float cept = cepts.get(0);
+			if (OpMath::IsNaN(cept) || 0 == cept || 1 == cept)
+				goto tryADifferentCenter;
+			float tNxR = testCurve.tangent(cept).normalize().cross(backRay);
+			if (fabs(tNxR) < WINDING_NORMAL_LIMIT
+					&& (!test->setLinear() || test->start.t >= cept || cept >= test->end.t)) {
+				goto tryADifferentCenter;
+			}
+			OpPoint pt = testCurve.ptAtT(cept);
+			distance.emplace_back(test, center - pt.choice(perpendicular), cept);
+		}
+		goto foundRayIntercept;
+	tryADifferentCenter:
+		mid /= 2;
+		midEnd = midEnd < .5 ? 1 - mid : mid;
+		float middle = OpMath::Interp(edge->ptBounds.ltChoice(axis), edge->ptBounds.rbChoice(axis), 
+				midEnd);
+		const OpCurve& edgeCurve = edge->setCurve();  // ok to be in loop (lazy)
+		edgeCenterT = edgeCurve.center(axis, middle);
+		if (OpMath::IsNaN(edgeCenterT) || mid <= 1.f / 256.f) {	// give it at most eight tries
+			edge->fail = EdgeFail::recalcCenter;
+			edge->winding.zero(ZeroReason::failCenter);
+			return;
+		}
+		// if find ray intercept can't find, restart with new center, normal, distance, etc.
+		center = edgeCurve.ptAtT(edgeCenterT).choice(perpendicular);
+		assert(!OpMath::IsNaN(center));
+		normal = edgeCurve.ptAtT(edgeCenterT).choice(axis);
+		assert(!OpMath::IsNaN(normal));
+		distance.clear();
+	} while (true);
+foundRayIntercept:
 	std::sort(distance.begin(), distance.end(), compareDistance);	// sorts from high to low
 	EdgeDistance* last = &distance.front();
-	// leftmost edge may have no prior, no next; if the right edge has no effect
+	// leftmost edge may have no prior
 	while (last->edge != edge) {
 		EdgeDistance* next = last + 1;
 		OpEdge* lastEdge = last->edge;
@@ -427,8 +470,17 @@ FoundWindings OpEdges::setWindings() {
 							continue;
 						}
 						// project ray between short length and end of added dual length
-						OpPtT ptT = connector->findRayIntercept(edge, testStartXY, 
-								connectorLimit, axis, backRay);
+					//	start here; // find ray intercept needs t values, not test start x y, connector limit
+						// connector end may be beyond (or not as far as) limit
+						// find ray intercept should take range of test start x y to smaller of connector limit, upper limit
+						float rayLimit = OpMath::Between(lowerLimit, connectorLimit, upperLimit) ?
+							connectorLimit : upperLimit;
+						const OpCurve& connectorCurve = connector->setCurve();
+						float connectorCenterT = connectorCurve.center(axis, 
+								(testStartXY + rayLimit) / 2);
+						float connectorNormal = connectorCurve.ptAtT(connectorCenterT).choice(axis);
+						OpPtT ptT = connector->findRayIntercept(edge, connectorNormal, testStartXY, 
+								rayLimit, axis, backRay);
 						// detect if edges diverge
 						assert(!OpMath::IsNaN(ptT.t));	// just here to suppress warning
 						assert(0); // incomplete
