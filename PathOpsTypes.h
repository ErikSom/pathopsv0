// (c) 2023, Cary Clark cclark2@gmail.com
#ifndef PathOpsTypes_DEFINED
#define PathOpsTypes_DEFINED

#include "OpMath.h"

enum class OpType;
struct OpPair;
enum class WindKeep;
struct OpWinding;

namespace PathOpsV0Lib {

/* think about:
data is clumped into points, which may have 2, 3, or more components
pathops only uses first two: x, y
caller may carry other data, such as conic weight or z

the data could be int or double (or long double etc.) instead of float
allow this?

the type describes what the data is, and how many floats it uses
the intent is to do this through a callback

*/

struct Context;

/* A collection of curves in an operand that share the same fill rules.
 */
struct Contour;

/* Curve describes a set of continuous points from start to end.
   Curve's points must be contained by a rectangle bounded by start and end.
   Curve's points must monotonically vary from start to end in x and y.
 */
struct CurveData {
	OpPoint start;
	OpPoint end;
	char optionalAdditionalData[];
};

struct Curve {
	CurveData* data;
	size_t size;  // total size in bytes, including additional data, if any
	OpType type;
};

/* convenience for adding curve to contour
 */
struct AddCurve {
	Context* context;
	OpPoint* points;
	size_t size;	// size of points in bytes
	OpType type;
};

/* caller defined data representing how curves in a contour cover area
 */
struct WindingData;

struct Winding {
	WindingData* data;
	size_t size;
};

/* convenience for adding winding data to contour
 */
struct AddWinding {
	Contour* contour;
	int* windings;
	size_t size;
};

typedef int ContourID;

/* the contour ID and number of curves in the contour
 */
struct ContourData {
	int contourID;
	int curves;
};

/* the number of contours and overall number of curves 
 */
struct PathData {
	int contours;
	int curves;
};

// callbacks

// intersects the curve and axis at the axis intercept
typedef OpRoots (*AxisRawHit)(CurveData* , Axis , float axisIntercept, MatchEnds);

// returns length of data used by this type of curve
//typedef size_t (*CurveLength)();

// returns number of points in curve, including start and end (minimum 2)
typedef size_t (*PtCount)();

// returns true if curve is line
typedef bool (*CurveIsLine)(const CurveData* ); 

// returns true if curve degenerates to line
typedef bool (*CurveIsLinear)(const CurveData* ); 

// returns OpPoint at parameter t, where: t=0 is start, t=1 is end
typedef OpPoint (*PtAtT)(CurveData* , float t);

// returns high precision OpPoint at parameter t, where: t=0 is start, t=1 is end
typedef OpPoint (*DoublePtAtT)(CurveData* , float t);

// returns true if additional data is equal (e.g., lines are always equal) 
typedef bool (*CurvesEqual)(CurveData* , Curve );

// returns array of parameter t values and points where line intersects curve
typedef OpRootPts (*LineIntersect)(CurveData* curve, Curve line); 

// receives overall stats for next contour generated by Resolve()
typedef ContourData (*NextContour)();

// points to storage for next curve generated by Resolve()
typedef OpType (*NextCurve)(CurveData* );

// receives overall stats for next path generated by Resolve()
typedef PathData (*NextPath)();

// returns point constructs curve's hull; the curve is tightly contained by the hull's polygon
typedef OpPoint (*CurveHull)(const CurveData*, int index);

// returns normal vector at parameter t, where: t=0 is start, t=1 is end
typedef OpVector (*CurveNormal)(const CurveData*, float t);

// reverses order of control points, if there is more than one
typedef void (*CurveReverse)(const CurveData*);

// computes part of Curve from parameter t1 to t2, both from zero to one
typedef OpCurve (*SubDivide)(Context* , Curve , OpPtT t1, OpPtT t2);

// returns tangent vector at parameter t, where: t=0 is start, t=1 is end
typedef OpVector (*CurveTangent)(const CurveData*, float t);

// return control points in curve data
typedef std::vector<OpPoint*>(*CurveControls)(const CurveData* );

// set transformed control points in curve data
typedef void (*SetControls)(const CurveData* , std::vector<OpPoint>& );

// returns either x or y pair at parameter t, where: t=0 is start, t=1 is end
typedef OpPair (*XYAtT)(CurveData* , OpPair t, XyChoice );

#if OP_DEBUG_IMAGE
// returns tangent vector at parameter t, where: t=0 is start, t=1 is end
typedef void (*DebugAddToPath)(const CurveData*, class SkPath& );
#endif

struct CallBacks {
	AxisRawHit axisRawHitFuncPtr;
	CurveHull curveHullFuncPtr;
	CurveIsLine curveIsLineFuncPtr;
	CurveIsLinear curveIsLinearFuncPtr;
	CurveControls curveControlsFuncPtr;
	SetControls setControlsFuncPtr;
//	CurveLength curveLengthFuncPtr;
	CurveNormal curveNormalFuncPtr;
	CurveReverse curveReverseFuncPtr;
	CurveTangent curveTangentFuncPtr;
	CurvesEqual curvesEqualFuncPtr;
	PtAtT  ptAtTFuncPtr;
	DoublePtAtT  doublePtAtTFuncPtr;
	PtCount ptCountFuncPtr;
	SubDivide subDivideFuncPtr;
	XYAtT xyAtTFuncPtr;
#if OP_DEBUG_IMAGE
	DebugAddToPath debugAddToPathFuncPtr;
#endif
};

// initializes winding to its starting value
//typedef void (*WindingInit)(Context* , Contour* , Curve , Winding );

// returns if curve transitions to a filled area and is kept; or if curve is discarded
typedef WindKeep (*WindingKeep)(Contour* , Winding winding, Winding sum);

// returns length of winding data used by this type of curve
// typedef size_t (*WindingLength)(Curve );

// Combines opp's winding with destination; zero's opp's winding. backwards is true if
// opp curve and destination curve are reversed.
// Returns true if, after move, destination's winding is non-zero.
typedef bool (*WindingMove)(Winding opp, bool backwards, Winding destination);

// initializes winding sum to its starting value 
typedef void (*WindingSetSum)(Winding winding, Winding* sum);

#if OP_DEBUG_DUMP
typedef void (*WindingDumpIn)(const char*& str , Winding );
typedef std::string (*WindingDumpOut)(Winding );
#endif

struct ContourCallBacks {
//	WindingInit windingInitFuncPtr;
	WindingKeep windingKeepFuncPtr;
//	WindingLength windingLengthFuncPtr;
	WindingMove windingMoveFuncPtr;
	WindingSetSum windingSetSumFuncPtr;
#if OP_DEBUG_DUMP
	WindingDumpIn windingDumpInFuncPtr;
	WindingDumpOut windingDumpOutFuncPtr;
#endif
};


} // namespace PathOpsV0Lib

#endif